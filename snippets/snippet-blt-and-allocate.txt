[cpu 8086]
[org 100h]

section .data

err_notEnoughMemory: db `Error: Not enough free memory to play this dazzling game!\r\n$`


section .bss

originalVideoMode: resb 1
offscreenSeg: resw 1
buf16: resb 16

struc rect_bitblt
  .x: resw 1
  .y: resw 1
  .w: resw 1
  .h: resw 1
endstruc


section .text

; Free up some memory by reminding DOS we are only a 64K .COM program
mov bx, sp
mov cl, 4
shr bx, cl
inc bx
mov ah, 0x4a
;int 21h

; Try to allocate 32KB (0x8000 bytes) of memory for an offscreen buffer
mov bx, 0x8000/16
mov ah, 0x48
int 21h
jnc memOK
  ; If carry bit is set the allocation failed - print message and exit
  mov	dx, err_notEnoughMemory
  mov	ah, 9
  int	21h
  ret
memOK:
mov [offscreenSeg], ax

mov ax, 0f00h                ; AH = 0x0f (get video mode)
int 10h                      ; Call INT10h fn 0x0f which will store the current video mode in AL
mov [originalVideoMode], al  ; Store it into the byte pointed to by originalVideoMode.

mov ax, 0009h                ; AH = 0x00 (set video mode), AL = 9 (new mode)
int 10h                      ; Call INT10h fn 0 to change the video mode

; Clear offscreen framebuffer to green
mov dl, 2
call clearBuffer

;call bltAll

; Copy a 50x50 rectangle at position 50, 50
mov ax, 50
mov [rect_bitblt.x], ax
mov [rect_bitblt.y], ax
mov [rect_bitblt.w], ax
mov [rect_bitblt.h], ax
call bltRect

; Wait for a key
mov ah, 08h
int 21h

xor ax, ax
mov al, [originalVideoMode]
int 10h

ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Clear the framebuffer at ES to palette color DL.
; Copies DL to the high and low nibbles of 32K bytes
; starting at ES.
clearBuffer:
  push es   ; Save current ES and put offscreenBuf segment there
  mov ax, [offscreenSeg]
  mov es, ax
  ; Copy the low nibble of DL to the high nibble
  and dl, 0x0f ; Clear the high nibble
  mov dh, dl   ; Make a copy in DH
  mov cl, 4
  shl dh, cl   ; Shift DH left 4 bits (make the low nibble the high nibble)
  or dl, dh    ; Combine the nibbles
  mov dh, dl   ; Copy low word to high word (now all 4 nibbles are the same)
  mov ax, dx
  xor di, di
  mov cx, 0x4000
  rep stosw    ; Copy the word in AX 32K times (16K words = 0x4000)
  pop es       ; Restore ES
  ret

; Copies the rectangle specified by rect_bitblt from the
; offscreen buffer to the framebuffer.
bltRect:
  push ds         ; Set DS to source (offscreen buffer) and
  push es         ; ES to destination (framebuffer)
  mov ax, [offscreenSeg]
  mov ds, ax
  mov ax, 0xb800
  mov es, ax

  mov cx, [cs:rect_bitblt.h] ; Number of lines to copy

.copyLine:
  mov ax, [cs:rect_bitblt.h]
  sub ax, cx
  add ax, [cs:rect_bitblt.y]  ; Now AX is vertical line number

  ; Set SI and DI to start byte of left side of line

  mov bx, 4
  xor dx, dx
  div bx          ; DX = bank number (0-3), AX = row within bank
  xchg ax, dx     ; AX = bank number (0-3), DX = row within bank
  mov bx, 02000h  ; bank width
  push dx
  mul bx
  mov si, ax      ; Now SI is the bank memory offset
  pop ax          ; AX = DX, the row number within the bank

  ; Calc byte index of pixel: SI += (AX * 320 + rect_bitblt.x) / 2
  mov bx, 320
  mul bx
  add ax, [cs:rect_bitblt.x]
  shr ax, 1
  add si, ax

  mov di, si
  push cx
  mov cx, [cs:rect_bitblt.w] ; Width of each line to copy
  shr cx, 1               ; Because each byte encodes 2 pixels
  rep movsb               ; Copy CX bytes

  pop cx
  loop .copyLine

.done:
  pop ds          ; Restore our segment registers
  pop es
  ret

; Copies the whole offscreen buffer to the framebuffer.
bltAll:
  push ds         ; Set DS to source (offscreen buffer) and
  push es         ; ES to destination (framebuffer)
  mov ax, [offscreenSeg]
  mov ds, ax
  mov ax, 0xb800
  mov es, ax
  xor si, si      ; Set index pointers to 0
  xor di, di
  mov cx, 0x4000
  rep movsw       ; Copy 32KB (16K words = 0x4000)
  pop ds          ; Restore our segment registers
  pop es
  ret
