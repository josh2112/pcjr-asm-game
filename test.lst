     1                                  ; test.asm: Playing around with IBM PCjr text, graphics and sound routines
     2                                  
     3                                  [cpu 8086]
     4                                  [org 100h]
     5                                  
     6                                  %include 'stdio.mac'
     1                              <1> ; stdio.mac: Input/output routines for 8088 assembly
     2                              <1> ;
     3                              <1> ; Expects the following initialized data:
     4                              <1> ; str_crlf: db 0dh, 0ah, '$'
     5                              <1> 
     6                              <1> ; Much like C/C++, these %ifndef/%define/%endif keep the file from being
     7                              <1> ; accidentally included multiple times
     8                              <1> %ifndef STDIO_MAC
     9                              <1> %define STDIO_MAC
    10                              <1> 
    11                              <1> ; Prints the given '$'-terminated string.
    12                              <1> %macro print 1
    13                              <1> 	mov dx, %1
    14                              <1> 	mov ah, 9h
    15                              <1> 	int 21h
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> ; Prints the given '$'-terminated string and newline.
    19                              <1> %macro println 1
    20                              <1> 	print %1
    21                              <1> 	print str_crlf
    22                              <1> %endmacro
    23                              <1> 
    24                              <1> %macro intToString 2
    25                              <1>   mov di, %1
    26                              <1>   mov ax, %2
    27                              <1>   call int_to_string
    28                              <1> %endmacro
    29                              <1> 
    30                              <1> ; Waits for a key press using int 21h fn 08h (char input without echo)
    31                              <1> %macro waitForAnyKey 0
    32                              <1> 	mov ah, 08h
    33                              <1> 	int 21h
    34                              <1> %endmacro
    35                              <1> 
    36                              <1> %endif ; STDIO_MAC
     7                                  %include 'graphics.mac'
     1                              <1> 
     2                              <1> ; Sets the color of a pixel at an X,Y (column, row) location.
     3                              <1> ; Clobbers ax, bx, dl.
     4                              <1> ; %1: X (row)
     5                              <1> ; %2: Y (column)
     6                              <1> ; %3: color (4-bit pallete index)
     7                              <1> %macro setpixel 3
     8                              <1>   mov bx, %1
     9                              <1>   mov ax, %2
    10                              <1>   mov dl, %3
    11                              <1>   call putpixel
    12                              <1> %endmacro
     8                                  
     9                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    10                                  
    11                                  section .data
    12                                  
    13 00000000 0A0D24                  str_crlf: db 0xa, 0xd, '$'
    14                                  
    15 00000003 01                      is_running: db 1
    16 00000004 A000                    player_x: dw 160
    17 00000006 6400                    player_y: dw 100
    18                                  
    19                                  section .bss
    20                                  
    21 00000000 <res 00000001>          originalVideoMode: resb 1
    22 00000001 <res 00000010>          buf16: resb 16
    23                                  
    24                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                                  
    26                                  section .text
    27                                  
    28                                  ; Get the initial video mode and save it to [originalVideoMode]
    29 00000000 B8000F                  mov ax, 0f00h                ; AH <- 0x0f (get video mode)
    30 00000003 CD10                    int 10h                      ; Call INT10h fn 0x0f which will store the current video mode in AL
    31 00000005 A2[0000]                mov [originalVideoMode], al  ; Store it into the byte pointed to by originalVideoMode.
    32                                  
    33                                  ; Change the video mode to Mode 9 (320x200, 16 colors)
    34 00000008 B80900                  mov ax, 9h                   ; AH <- 0x00 (set video mode), AL <- 9 (new mode)
    35 0000000B CD10                    int 10h                      ; Call INT10h fn 0 to change the video mode
    36                                  
    37                                  game_loop:
    38 0000000D B201                      mov dl, 1
    39 0000000F E87D00                    call cls
    40                                  
    41 00000012 E8CD00                    call draw_player
    42                                  
    43 00000015 31C0                      xor ax, ax
    44 00000017 CD16                      int 16h
    45 00000019 E88F00                    call process_key
    46                                  
    47 0000001C 803E[0300]00              cmp byte [is_running], 0
    48 00000021 75EA                      jne game_loop
    49                                  
    50                                  clean_up:
    51                                  
    52                                  ; Change the video mode back to whatever it was before (the value stored in
    53                                  ; originalVideoMode)
    54 00000023 A0[0000]                mov al, [originalVideoMode]
    55 00000026 30E4                    xor ah, ah
    56 00000028 CD10                    int 10h
    57                                  
    58                                  ; Exit the program
    59 0000002A B8004C                  mov ax, 4c00h
    60 0000002D CD21                    int 21h
    61                                  
    62                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    63                                  
    64                                  %include 'formatting.asm'
     1                              <1> ; formatting.asm: Datatype conversion routines for 8088 assembly
     2                              <1> 
     3                              <1> ; Much like C/C++, these %ifndef/%define/%endif keep the file from being
     4                              <1> ; accidentally included multiple times
     5                              <1> %ifndef FORMATTING_ASM
     6                              <1> %define FORMATTING_ASM
     7                              <1> 
     8                              <1> ; Converts the signed integer in AX to a string and puts it in [DI]
     9                              <1> ; Returns the result (the original DI pointer) in AX
    10                              <1> ; Clobbers BX, CX, DX
    11                              <1> int_to_string:
    12 0000002F 57                  <1>   push di             ; Save the original DI pointer so we can pop it out
    13                              <1>                       ; and return it as AX
    14 00000030 BB0A00              <1>   mov bx, 10          ; Load divisor and clear counter
    15 00000033 31C9                <1>   xor cx, cx
    16 00000035 85C0                <1>   test ax, ax
    17 00000037 7906                <1>   jns .peelOffDigits  ; Is AX signed? If not, go to 'continue'
    18 00000039 C6052D              <1>   mov byte [di], '-'  ; Put a negative sign on the string and increment our pointer
    19 0000003C 47                  <1>   inc di
    20 0000003D F7D8                <1>   neg ax              ; Negate to make positive
    21                              <1>   .peelOffDigits:
    22 0000003F 31D2                <1>     xor dx, dx        ; Zero the high-word of the divisor
    23 00000041 F7F3                <1>     div bx            ; This will give us the remainder in DX
    24 00000043 52                  <1>     push dx           ; Push it onto the stack
    25 00000044 FEC1                <1>     inc cl            ; Increment our counter
    26 00000046 85C0                <1>     test ax, ax       ; If no remainder, we're done
    27 00000048 75F5                <1>     jnz .peelOffDigits
    28                              <1>   .buildString:
    29 0000004A 58                  <1>     pop ax            ; Pop out the next digit
    30 0000004B 0430                <1>     add al, '0'       ; Add 48 to get the ascii value
    31 0000004D AA                  <1>     stosb             ; Store the char in AL into [DI], then increment DI
    32 0000004E E2FA                <1>     loop .buildString
    33 00000050 C60524              <1>   mov byte [di], '$'  ; Terminate the string
    34 00000053 58                  <1>   pop ax              ; Pop the original DI into AX
    35 00000054 C3                  <1>   ret
    36                              <1> 
    37                              <1> %endif ; FORMATTING_ASM
    65                                  %include '320x200x16.asm'
     1                              <1> ; 320x200x16.asm: Drawing routines for Video Mode 9, 320x200 16-color
     2                              <1> 
     3                              <1> %ifndef _320X200X16_ASM
     4                              <1> %define _320X200X16_ASM
     5                              <1> 
     6                              <1> ; Puts color index DL in the pair of pixels specified by BX,AX (x,y)
     7                              <1> ; Clobbers AX, CX, DX
     8                              <1> putpixel:
     9 00000055 52                  <1>   push dx         ; Save the color because we need DX for MUL and DIV
    10 00000056 B90400              <1>   mov cx, 4
    11 00000059 31D2                <1>   xor dx, dx
    12 0000005B F7F1                <1>   div cx          ; DX = bank number (0-3), AX = row within bank
    13 0000005D 92                  <1>   xchg ax, dx     ; AX = bank number (0-3), DX = row within bank
    14 0000005E B90002              <1>   mov cx, 0200h   ; bank width
    15 00000061 52                  <1>   push dx
    16 00000062 F7E1                <1>   mul cx          ; AX = bank memory offset
    17 00000064 5A                  <1>   pop dx
    18 00000065 0500B8              <1>   add ax, 0b800h  ; offset by start of video memory
    19 00000068 8EC0                <1>   mov es, ax      ; ES = absolute start-of-bank address
    20                              <1> 
    21 0000006A 89D0                <1>   mov ax, dx
    22                              <1>   ; Now BX is the pixel column (x) and AX is the row (y) within the bank
    23                              <1> 
    24                              <1>   ; Calc byte index of pixel: AX = (AX * 320 + BX) / 2
    25 0000006C B94001              <1>   mov cx, 320
    26 0000006F F7E1                <1>   mul cx
    27 00000071 01D8                <1>   add ax, bx
    28 00000073 D1E8                <1>   shr ax, 1
    29                              <1> 
    30 00000075 89C6                <1>   mov si, ax        ; Put byte index in string-source register
    31 00000077 268A04              <1>   mov al, [es:si]   ; Pull the pixel pair out into AL
    32                              <1> 
    33 0000007A 5A                  <1>   pop dx            ; Get our color back in DX
    34 0000007B 720A                <1>   jc .setLow        ; If AX was odd, carry bit should be set from the right-shift. If so, set the low
    35                              <1>                     ; nibble, otherwise set the high nibble
    36                              <1>   .setHigh:
    37 0000007D 240F                <1>     and al, 0x0f    ; Clear the high nibble
    38 0000007F B104                <1>     mov cl, 4
    39 00000081 D2E2                <1>     shl dl, cl
    40 00000083 08D0                <1>     or al, dl       ; Set it from the color index in DL
    41 00000085 EB04                <1>     jmp .finish
    42                              <1> 
    43                              <1>   .setLow:
    44 00000087 24F0                <1>     and al, 0xf0    ; Clear the low nibble
    45 00000089 08D0                <1>     or al, dl       ; Set it from the color index in DL
    46                              <1> 
    47                              <1>   .finish:
    48 0000008B 268804              <1>     mov [es:si], al  ; Push the updated pixel pair back into memory
    49 0000008E C3                  <1>     ret
    50                              <1> 
    51                              <1> ; Fills the framebuffer with the color indexed by the low nibble of DL
    52                              <1> cls:
    53                              <1>   ; Copy the low nibble of DL to the high nibble
    54 0000008F 80E20F              <1>   and dl, 0x0f ; Clear the high nibble
    55 00000092 88D6                <1>   mov dh, dl   ; Make a copy in DH
    56 00000094 B104                <1>   mov cl, 4
    57 00000096 D2E6                <1>   shl dh, cl   ; Shift DH left 4 bits (make the low nibble the high nibble)
    58 00000098 08F2                <1>   or dl, dh    ; Combine the nibbles
    59 0000009A 88D6                <1>   mov dh, dl
    60                              <1> 
    61 0000009C B800B8              <1>   mov ax, 0xb800
    62 0000009F 8EC0                <1>   mov es, ax     ; Set ES to point to the framebuffer
    63 000000A1 31FF                <1>   xor di, di     ; Set DI to 0 (STOSW will copy to ES:DI)
    64 000000A3 89D0                <1>   mov ax, dx
    65 000000A5 B90040              <1>   mov cx, 0x4000 ; Fill 32KB (0x4000 16-bit words)
    66 000000A8 F3AB                <1>   rep stosw      ;
    67                              <1> 
    68 000000AA C3                  <1>   ret
    69                              <1> 
    70                              <1> %endif ; _320X200X16_ASM
    66                                  
    67                                  process_key:
    68 000000AB 80FC01                    cmp ah, 1
    69 000000AE 7507                      jne .testUp
    70 000000B0 C606[0300]00              mov byte [is_running], 0
    71 000000B5 EB2A                      jmp .done
    72                                  .testUp:
    73 000000B7 80FC48                    cmp ah, 0x48
    74 000000BA 7506                      jne .testDown
    75 000000BC FF0E[0600]                dec word [player_y]
    76 000000C0 EB1F                      jmp .done
    77                                  .testDown:
    78 000000C2 80FC50                    cmp ah, 0x50
    79 000000C5 7506                      jne .testLeft
    80 000000C7 FF06[0600]                inc word [player_y]
    81 000000CB EB14                      jmp .done
    82                                  .testLeft:
    83 000000CD 80FC4B                    cmp ah, 0x4b
    84 000000D0 7506                      jne .testRight
    85 000000D2 FF0E[0400]                dec word [player_x]
    86 000000D6 EB09                      jmp .done
    87                                  .testRight:
    88 000000D8 80FC4D                    cmp ah, 0x4d
    89 000000DB 7504                      jne .done
    90 000000DD FF06[0400]                inc word [player_x]
    91                                  .done:
    92 000000E1 C3                        ret
    93                                  
    94                                  draw_player:
    95 000000E2 B90800                    mov cx, 8
    96                                    .drawRow:
    97 000000E5 B80800                      mov ax, 8
    98 000000E8 29C8                        sub ax, cx
    99 000000EA 0306[0600]                  add ax, [player_y]      ; AX = row (y)
   100 000000EE 51                          push cx
   101 000000EF B90800                      mov cx, 8
   102                                      .drawPixel:
   103 000000F2 BB0800                        mov bx, 8
   104 000000F5 29CB                          sub bx, cx
   105 000000F7 031E[0400]                    add bx, [player_x]    ; BX = col (x)
   106 000000FB 50                            push ax
   107 000000FC 51                            push cx
   108 000000FD B20A                          mov dl, 10
   109 000000FF E853FF                        call putpixel         ; (BX, AX) = (x,y), DL = color
   110 00000102 59                            pop cx
   111 00000103 58                            pop ax
   112 00000104 E2EC                          loop .drawPixel
   113 00000106 59                          pop cx
   114 00000107 E2DC                        loop .drawRow
   115 00000109 C3                        ret
